<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Street Fighter: Parry Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            color: white;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            border: 4px solid #555;
            box-shadow: 0 0 100px rgba(255, 0, 0, 0.2);
            max-width: 95vw;
            max-height: 80vh;
        }
        .arcade-font {
            font-family: 'Permanent Marker', cursive;
        }
        
        .screen-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            text-align: center;
        }

        #start-screen {
            background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            overflow: hidden;
        }
        .city-silhouette {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 40%;
            background: #050505;
            z-index: -1;
            clip-path: polygon(0% 100%, 0% 40%, 5% 40%, 5% 20%, 10% 20%, 10% 50%, 15% 50%, 15% 10%, 25% 10%, 25% 40%, 30% 40%, 30% 0%, 40% 0%, 40% 30%, 45% 30%, 45% 15%, 55% 15%, 55% 45%, 60% 45%, 60% 5%, 75% 5%, 75% 35%, 85% 35%, 85% 25%, 90% 25%, 90% 50%, 100% 50%, 100% 100%);
        }

        .hud-container {
            position: absolute;
            top: 20px;
            width: 95%;
            display: none; 
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 50;
        }
        
        .fighter-section {
            width: 42%;
            display: flex;
            flex-direction: column;
        }
        .health-bar-container {
            width: 100%;
            height: 30px;
            background: #444;
            border: 2px solid #fff;
            position: relative;
            transform: skewX(-15deg);
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to bottom, #ffcc00, #ff9900);
            transition: width 0.3s ease-out;
        }
        
        .stamina-container {
            width: 60%;
            height: 8px;
            background: rgba(0,0,0,0.4);
            border: 1px solid #777;
            margin-top: 5px;
            transform: skewX(-15deg);
            overflow: hidden;
        }
        .stamina-fill {
            height: 100%;
            width: 100%;
            background: #fff;
            transition: width 0.1s;
        }

        .hp-value {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px black;
            transform: skewX(15deg); 
            z-index: 10;
        }

        .name-tag {
            font-weight: bold;
            font-style: italic;
            text-transform: uppercase;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 0 #ff0000;
            margin-bottom: 4px;
        }

        .guard-bar {
            width: 80%;
            height: 10px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #777;
            margin-top: 6px;
            transform: skewX(-15deg);
            overflow: hidden;
        }
        .guard-fill {
            height: 100%;
            width: 0%;
            background: #00ffff;
            box-shadow: 0 0 15px #00ffff;
            transition: width 0.2s;
        }

        .btn-arcade {
            background: #cc0000;
            color: white;
            padding: 15px 40px;
            font-size: 24px;
            border: 4px solid white;
            cursor: pointer;
            transform: skewX(-10deg);
            box-shadow: 6px 6px 0 #000;
            transition: 0.1s;
            position: relative;
            overflow: hidden;
        }
        .btn-arcade:hover {
            background: #ff0000;
            transform: scale(1.1) skewX(-10deg);
        }

        .announce-overlay {
            position: absolute;
            font-size: 140px;
            font-weight: 900;
            color: #ffcc00;
            text-shadow: 8px 8px 0 #ff0000;
            pointer-events: none;
            z-index: 100;
            display: none;
            text-align: center;
            width: 100%;
            letter-spacing: -5px;
        }

        .control-btns {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 30px;
            z-index: 60;
        }

        .upgrade-card {
            background: #111;
            border: 2px solid #444;
            padding: 20px;
            margin: 10px;
            width: 250px;
            cursor: pointer;
            transition: 0.2s;
            transform: skewX(-5deg);
        }

        #controls-instruction {
            margin-top: 30px;
            background: rgba(0,0,0,0.6);
            padding: 15px 30px;
            border: 2px solid #555;
            border-radius: 4px;
            transform: skewX(-5deg);
        }
        .key-hint {
            color: #ffcc00;
            font-weight: bold;
            margin-right: 5px;
        }
    </style>
</head>
<body>

    <div id="start-screen" class="screen-overlay">
        <div class="city-silhouette"></div>
        <div class="relative mb-6">
            <h1 class="text-8xl arcade-font text-white italic" style="text-shadow: 10px 10px 0 #ff0000;">PARRY MASTER</h1>
        </div>
        <p class="text-2xl text-yellow-400 mb-8 tracking-[0.3em] arcade-font uppercase animate-pulse">Retro Arcade Fighter</p>
        
        <button onclick="startGame()" class="btn-arcade arcade-font italic">START GAME</button>
        
        <div id="controls-instruction" class="text-lg">
            <p class="mb-2 text-gray-400 font-bold uppercase tracking-widest text-sm">How to Play</p>
            <div class="flex gap-6 text-white arcade-font">
                <div><span class="key-hint">SPACE</span> : PARRY / DEFEND</div>
                <div><span class="key-hint">X</span> : HEAL (GOURD)</div>
            </div>
            <p class="mt-2 text-xs text-blue-400 italic italic">Tip: Parry enemy attacks to break their guard!</p>
        </div>
    </div>

    <div id="gameover-screen" class="screen-overlay" style="display: none;">
        <h2 class="text-9xl arcade-font text-red-600 mb-4 italic" style="text-shadow: 10px 10px 0 #fff;">K.O.</h2>
        <p id="final-level" class="text-2xl text-white mb-12 arcade-font italic">ROUND REACHED: 1</p>
        <button onclick="resetGame()" class="btn-arcade arcade-font italic">CONTINUE?</button>
    </div>

    <div id="upgrade-overlay" class="screen-overlay" style="display: none;">
        <h2 class="text-6xl font-black text-white mb-2 arcade-font italic">BONUS STAGE</h2>
        <p class="text-yellow-400 mb-10 tracking-widest uppercase text-xl font-bold">SELECT UPGRADE</p>
        <div id="upgrade-options" class="flex flex-wrap justify-center"></div>
    </div>

    <div id="announce" class="announce-overlay arcade-font">FIGHT!</div>

    <div id="hud" class="hud-container">
        <div class="fighter-section items-start pl-5">
            <div class="name-tag arcade-font">RYU</div>
            <div class="health-bar-container">
                <div id="player-hp-val" class="hp-value">100 / 100</div>
                <div id="player-hp-fill" class="health-fill"></div>
            </div>
            <div class="stamina-container">
                <div id="player-stamina-fill" class="stamina-fill"></div>
            </div>
            <div id="p-stats" class="text-[10px] text-gray-400 font-bold uppercase mt-6">POWER: 25 | DEFENSE: 0</div>
        </div>

        <div class="mx-5 flex flex-col items-center">
            <div class="text-4xl font-bold arcade-font italic text-red-600 drop-shadow-lg">VS</div>
            <div id="level-display" class="text-xl font-black mt-2 text-white arcade-font italic tracking-tighter">ROUND 1</div>
        </div>

        <div class="fighter-section items-end pr-5">
            <div class="name-tag arcade-font">BISON</div>
            <div class="health-bar-container">
                <div id="enemy-hp-val" class="hp-value">100 / 100</div>
                <div id="enemy-hp-fill" class="health-fill"></div>
            </div>
            <div class="guard-bar">
                <div id="enemy-guard-fill" class="guard-fill"></div>
            </div>
        </div>
    </div>

    <div id="game-controls" class="control-btns">
        <div id="gourd-btn" class="bg-blue-700 border-2 border-white px-6 py-2 transform skew-x-[-10deg] cursor-pointer hover:bg-blue-500 arcade-font">
            HEAL (X) : <span id="gourd-count" class="text-yellow-400">3</span>
        </div>
        <div id="giveup-btn" class="bg-gray-800 border-2 border-white px-6 py-2 transform skew-x-[10deg] cursor-pointer hover:bg-red-700 arcade-font">
            QUIT
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const playerHpFill = document.getElementById('player-hp-fill');
    const playerHpVal = document.getElementById('player-hp-val');
    const playerStaminaFill = document.getElementById('player-stamina-fill');
    const enemyHpFill = document.getElementById('enemy-hp-fill');
    const enemyHpVal = document.getElementById('enemy-hp-val');
    const enemyGuardFill = document.getElementById('enemy-guard-fill');
    const announceEl = document.getElementById('announce');
    const gourdCountEl = document.getElementById('gourd-count');
    const upgradeOverlay = document.getElementById('upgrade-overlay');
    const upgradeOptions = document.getElementById('upgrade-options');
    const pStatsEl = document.getElementById('p-stats');
    
    const startScreen = document.getElementById('start-screen');
    const gameoverScreen = document.getElementById('gameover-screen');
    const hud = document.getElementById('hud');
    const gameControls = document.getElementById('game-controls');

    canvas.width = 1000;
    canvas.height = 500;

    // --- SF AUDIO ENGINE ---
    let audioCtx = null;
    let bgmInterval = null;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    function playSound(freq, type, duration, vol = 0.1) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function startBGM() {
        if (!audioCtx) return;
        stopBGM();
        startSyntheticBGM();
    }

    function startSyntheticBGM() {
        const tempo = 130; 
        const beat = 60 / tempo;
        let step = 0;

        const bassPattern = [110, 110, 110, 130, 110, 110, 146, 130];
        const melodyPattern = [220, 0, 220, 246, 261, 0, 293, 261, 246, 0, 220, 196, 220, 0, 0, 0];

        const playNote = (freq, vol, type, dur, time) => {
            if (freq === 0) return;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, time);
            g.gain.setValueAtTime(vol, time);
            g.gain.exponentialRampToValueAtTime(0.001, time + dur);
            osc.connect(g);
            g.connect(audioCtx.destination);
            osc.start(time);
            osc.stop(time + dur);
        };

        const tick = () => {
            if (gameState !== 'PLAYING') return;
            const now = audioCtx.currentTime;
            playNote(bassPattern[step % 8], 0.04, 'triangle', beat * 0.8, now);
            if (step % 4 === 0) playNote(60, 0.1, 'sine', 0.1, now);
            if (step % 8 === 4) {
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0; i<data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const g = audioCtx.createGain();
                g.gain.setValueAtTime(0.05, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                noise.connect(g);
                g.connect(audioCtx.destination);
                noise.start(now);
            }
            const mFreq = melodyPattern[step % 16];
            if (mFreq > 0) playNote(mFreq, 0.03, 'square', beat * 1.5, now);
            step++;
        };

        bgmInterval = setInterval(tick, beat * 1000);
    }

    function stopBGM() {
        if (bgmInterval) clearInterval(bgmInterval);
    }

    const sfx = {
        parry: () => playSound(880, 'square', 0.1, 0.2),
        hit: () => playSound(150, 'sawtooth', 0.2, 0.2),
        deathblow: () => {
            playSound(100, 'sawtooth', 0.5, 0.3);
            playSound(200, 'square', 0.3, 0.2);
        },
        heal: () => {
            playSound(440, 'sine', 0.1, 0.1);
            setTimeout(() => playSound(660, 'sine', 0.1, 0.1), 50);
            setTimeout(() => playSound(880, 'sine', 0.2, 0.1), 100);
        },
        miss: () => playSound(80, 'sine', 0.1, 0.2)
    };

    // --- GAME STATE & LOGIC ---
    let gameState = 'START'; 
    let currentLevel = 1;
    let stats = { maxHp: 100, hp: 100, posturePower: 25, maxGourds: 3, gourds: 3, defense: 0, stamina: 100 };
    let enemy = { maxHp: 100, hp: 100, guard: 0, state: 'idle', timer: 80, winding: 80, damage: 10 };

    let particles = [];
    let damageTexts = [];
    let shake = 0;
    let lastTime = 0;
    const fps = 60;
    const interval = 1000 / fps;

    const BUFFS = [
        { title: "POWER UP", desc: "Guard Damage +10", color: "#00ffff", apply: () => stats.posturePower += 10 },
        { title: "MAX HP UP", desc: "Max HP +50", color: "#ffcc00", apply: () => { stats.maxHp += 50; stats.hp = stats.maxHp; } },
        { title: "RESOURCES", desc: "Heal Item +1", color: "#3b82f6", apply: () => { stats.maxGourds += 1; } },
        { title: "DEFENSE", desc: "Defense +5", color: "#94a3b8", apply: () => stats.defense += 5 }
    ];

    function startGame() {
        initAudio();
        startScreen.style.display = 'none';
        gameoverScreen.style.display = 'none';
        upgradeOverlay.style.display = 'none';
        hud.style.display = 'flex';
        gameControls.style.display = 'flex';
        resetStats();
        setupLevel(1);
        gameState = 'PLAYING';
        startBGM();
        announce("FIGHT!");
    }

    function resetGame() { startGame(); }

    function resetStats() {
        currentLevel = 1;
        stats = { maxHp: 100, hp: 100, posturePower: 25, maxGourds: 3, gourds: 3, defense: 0, stamina: 100 };
    }

    function setupLevel(lvl) {
        currentLevel = lvl;
        stats.hp = stats.maxHp; 
        stats.stamina = 100;
        stats.gourds = stats.maxGourds; 
        
        enemy.maxHp = 100 + (lvl * 35);
        enemy.hp = enemy.maxHp;
        enemy.guard = 0;
        enemy.timer = 100;
        enemy.winding = Math.max(30, 120 - (lvl * 8)); 
        enemy.damage = 10 + (lvl * 5); 
        enemy.state = 'idle';
        document.getElementById('level-display').innerText = `ROUND ${lvl}`;
        updateUI();
    }

    function announce(text, duration = 1000) {
        announceEl.innerText = text;
        announceEl.style.display = 'block';
        setTimeout(() => announceEl.style.display = 'none', duration);
    }

    function showUpgradeScreen() {
        gameState = 'UPGRADE';
        stopBGM();
        upgradeOverlay.style.display = 'flex';
        upgradeOptions.innerHTML = '';
        const selected = [...BUFFS].sort(() => 0.5 - Math.random()).slice(0, 3);
        selected.forEach(buff => {
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.innerHTML = `<h3 class="text-3xl arcade-font mb-2" style="color:${buff.color}">${buff.title}</h3><p class="text-sm text-gray-400 font-bold">${buff.desc}</p>`;
            card.onclick = () => {
                buff.apply();
                upgradeOverlay.style.display = 'none';
                gameState = 'PLAYING';
                startBGM();
                setupLevel(currentLevel + 1);
                announce(`ROUND ${currentLevel}`);
            };
            upgradeOptions.appendChild(card);
        });
    }

    function handleParry() {
        if (gameState !== 'PLAYING') return;
        if (enemy.state === 'attacking') {
            enemy.state = 'parried';
            enemy.timer = 40; 
            sfx.parry();
            let actualPower = stats.stamina < 20 ? Math.ceil(stats.posturePower * 0.5) : stats.posturePower;
            enemy.guard += actualPower;
            shake = 25;
            createParticles(500, 250, '#fff', 35);
            createDamageText(500, 150, stats.stamina < 20 ? "WEAK!" : "PARRY!", "#00ffff", true);
            stats.stamina = Math.min(100, stats.stamina + 10);
            if (enemy.guard >= 100) deathBlow();
        } else {
            sfx.miss();
            createDamageText(500, 150, "MISS!", "#ff0000", false);
            shake = 8;
            stats.stamina = Math.max(0, stats.stamina - 20);
        }
    }

    function deathBlow() {
        enemy.guard = 0;
        sfx.deathblow();
        const dmg = Math.ceil(enemy.maxHp * 0.55);
        enemy.hp -= dmg;
        shake = 60;
        createParticles(750, 300, '#ff0000', 60);
        
        // Damage number for enemy set to bright red (#ff0000)
        createDamageText(750, 180, `-${dmg}`, "#ff0000", true); 
        
        if (enemy.hp <= 5) {
            enemy.hp = 0;
            announce("WINNER!", 2000);
            setTimeout(showUpgradeScreen, 1500);
        }
    }

    function takeHit() {
        sfx.hit();
        const dmg = Math.max(5, enemy.damage - stats.defense);
        stats.hp -= dmg;
        shake = 40;
        createDamageText(250, 220, `-${dmg}`, "#ff3333", true);
        createParticles(250, 345, '#ff0000', 25);
        if (stats.hp <= 0) {
            stats.hp = 0;
            gameState = 'GAMEOVER';
            stopBGM();
            document.getElementById('final-level').innerText = `ROUND REACHED: ${currentLevel}`;
            gameoverScreen.style.display = 'flex';
            hud.style.display = 'none';
            gameControls.style.display = 'none';
        }
    }

    function createParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            particles.push({ x, y, vx: (Math.random()-0.5)*25, vy: (Math.random()-0.5)*25, life: 35, color });
        }
    }

    function createDamageText(x, y, text, color, big = false) {
        damageTexts.push({ x, y, text, color, life: 60, vy: -2, size: big ? 60 : 40 });
    }

    function updateUI() {
        playerHpFill.style.width = (stats.hp / stats.maxHp * 100) + '%';
        playerHpVal.innerText = `${Math.ceil(stats.hp)} / ${stats.maxHp}`;
        playerStaminaFill.style.width = stats.stamina + '%';
        playerStaminaFill.style.backgroundColor = stats.stamina < 20 ? '#ff3333' : '#ffffff';
        enemyHpFill.style.width = (enemy.hp / enemy.maxHp * 100) + '%';
        enemyHpVal.innerText = `${Math.ceil(enemy.hp)} / ${enemy.maxHp}`;
        enemyGuardFill.style.width = enemy.guard + '%';
        gourdCountEl.innerText = stats.gourds;
        pStatsEl.innerText = `POWER: ${stats.posturePower} | DEFENSE: ${stats.defense}`;
    }

    function updateLogic() {
        if (gameState !== 'PLAYING') return;
        stats.stamina = Math.min(100, stats.stamina + 0.3);
        if (enemy.state === 'idle') {
            enemy.timer--;
            if (enemy.timer <= 0) { enemy.state = 'winding'; enemy.timer = enemy.winding; }
        } else if (enemy.state === 'winding') {
            enemy.timer--;
            if (enemy.timer <= 0) { enemy.state = 'attacking'; enemy.timer = 15; }
        } else if (enemy.state === 'attacking') {
            enemy.timer--;
            if (enemy.timer <= 0) { takeHit(); enemy.state = 'idle'; enemy.timer = 60; }
        } else if (enemy.state === 'parried') {
            enemy.timer--;
            if (enemy.timer <= 0) { enemy.state = 'idle'; enemy.timer = 40; }
        }
        particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); });
        damageTexts.forEach((dt, i) => { dt.y += dt.vy; dt.life--; if (dt.life <= 0) damageTexts.splice(i, 1); });
        if (shake > 0) shake *= 0.85;
        updateUI();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        if (shake > 0.5) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
        ctx.fillStyle = '#111'; ctx.fillRect(0, 420, canvas.width, 80);
        ctx.strokeStyle = '#333'; ctx.lineWidth = 4;
        for(let i=0; i<canvas.width; i+=80) { ctx.beginPath(); ctx.moveTo(i, 420); ctx.lineTo(i-40, 500); ctx.stroke(); }

        if (gameState === 'PLAYING') {
            // Player Visual
            ctx.fillStyle = stats.stamina < 20 && Date.now() % 200 < 100 ? '#ff8888' : '#fff'; 
            ctx.fillRect(220, 270, 70, 150); 
            ctx.fillStyle = '#ff0000'; ctx.fillRect(220, 285, 70, 12); 
            
            // Enemy Visual
            let eColor = '#cc0000';
            if (enemy.state === 'winding') eColor = '#ffff00';
            if (enemy.state === 'attacking') eColor = '#ffffff';
            if (enemy.state === 'parried') eColor = '#444444';
            ctx.fillStyle = eColor; ctx.fillRect(710, 250, 80, 170); 
            
            // Indicator logic
            if (enemy.state === 'winding') {
                const centerX = 750;
                const centerY = 190;
                
                // Ring Indicator
                const progress = enemy.timer / enemy.winding; // 1 to 0
                const baseSize = 40;
                const ringRadius = baseSize + (progress * 100);
                
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
                ctx.lineWidth = 6;
                ctx.strokeStyle = progress < 0.2 ? '#ff0000' : '#ffff00';
                ctx.globalAlpha = 0.6;
                ctx.stroke();
                
                // Static outer circle for reference
                ctx.beginPath();
                ctx.arc(centerX, centerY, baseSize, 0, Math.PI * 2);
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.restore();

                // Number Countdown
                ctx.save();
                ctx.textAlign = 'center'; ctx.fillStyle = progress < 0.2 ? '#ff0000' : '#ffcc00';
                ctx.font = 'bold 80px Permanent Marker';
                const count = Math.ceil(enemy.timer / (enemy.winding/3));
                ctx.fillText(count, centerX, centerY + 30);
                ctx.restore();
            }
            
            // Attack flash
            if (enemy.state === 'attacking') {
                ctx.save();
                ctx.beginPath();
                ctx.arc(750, 190, 50, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.8;
                ctx.fill();
                ctx.restore();
            }
        }

        particles.forEach(p => {
            ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 35;
            ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
        });

        damageTexts.forEach(dt => {
            ctx.save();
            ctx.fillStyle = dt.color; ctx.font = `italic 900 ${dt.size}px Permanent Marker`;
            ctx.textAlign = 'center'; ctx.globalAlpha = dt.life / 60;
            ctx.fillText(dt.text, dt.x, dt.y);
            ctx.restore();
        });
        ctx.restore();
    }

    function gameLoop(timestamp) {
        const deltaTime = timestamp - lastTime;
        if (deltaTime >= interval) {
            updateLogic();
            draw();
            lastTime = timestamp - (deltaTime % interval);
        }
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => {
        if (gameState === 'START' && e.code === 'Enter') startGame();
        if (gameState === 'GAMEOVER' && e.code === 'Enter') resetGame();
        if (gameState !== 'PLAYING') return;
        if (e.code === 'Space') handleParry();
        if (e.code === 'KeyX' && stats.gourds > 0 && stats.hp < stats.maxHp) {
            sfx.heal(); stats.gourds--; 
            const healAmt = Math.ceil(stats.maxHp * 0.4);
            stats.hp = Math.min(stats.maxHp, stats.hp + healAmt);
            createParticles(255, 345, '#00ff00', 30);
            createDamageText(250, 220, `+${healAmt}`, "#00ff00");
        }
    });

    document.getElementById('gourd-btn').onclick = () => window.dispatchEvent(new KeyboardEvent('keydown', { code: 'KeyX' }));
    document.getElementById('giveup-btn').onclick = () => { if (gameState === 'PLAYING') { gameState = 'GAMEOVER'; stopBGM(); gameoverScreen.style.display = 'flex'; } };

    requestAnimationFrame(gameLoop);
</script>
</body>
</html>
